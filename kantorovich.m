function [g,Dg,H,actual_vols] = kantorovich(w,X,target_vols,bx,periodic,varargin)

% [g,Dg,H,actual_vols] = kantorovich(w,X,target_vols,bx,periodic,varargin)
%
% The function evaluates the Kantorovich function g, its first derivative
% Dg, and its Hessian H, where the Kantorovich function is defined by 
%
% g(w)=\sum_i \int_{Lag_i(X,w)} (c(x,x_i)-w_i) dx + \sum_i (target_vols)_i w_i
%
% where 
%
% c(x,x_i) is either the standard quadratic cost \|x-x_i\|^2 
% (if periodic=false) or the periodic quadratic cost (if periodic=true),
%
% Lag_i(X,w) is the i-th Laguerre cell in the Laguerre tessellation of the 
% 3d box bx generated by (X,w), i.e., 
% Lag_i(X,w) = \{ x \in bx : c(x,x_i)-w_i \le c(x,x_j)-w_j for all j \}.
%
% Input arguments
%         w            - the weights of the Laguerre diagram, an Nx1 array
%         X            - the positions of the seeds, an Nx3 array
%         target_vols  - target volumes, an Nx1 array, 
%                        which must satisfy sum(target_vols)=volume(bx)
%         bx           - box size, a 1x3 array. This represents the cuboid
%                        with vertices (0,0,0), (bx(1),0,0), (0,bx(2),0), (bx(1),bx(2),0), 
%                        (0,0,bx(3)), (bx(1),0,bx(3)), (0,bx(2),bx(3)), (bx(1),bx(2),bx(3))
%         periodic     - periodic flag, a boolean true/false
%                        If periodic=false, then c is the standard quadratic cost
%                        If periodic=true, then c is the periodic quadratic cost
%         OPTcheckneighbours - optional argument, a boolean true/false
%                              Default is true. This argument is ignored if periodic=false. 
%                              Use checkneighbours=true for a robust (but slower) algorithm.
%    
% Return arguments
%         g            - the value of the Kantorovich function g(w)
%         Dg           - gradient of g with respect to w, an Nx1 array
%         H            - the Hessian D^2g, an NxN sparse matrix
%         actual_vols  - the actual volumes of the Laguerre diagram with
%         seeds X and weights w, an Nx1 array
%
% WARNING! By selecting periodic=true and checkneighbours=false there is 
% a risk that the Hessian H is incorrect. Proceed at your own risk!

%% Catch errors and process the optional argument

if(nargin==6)
    checkneighbours=varargin{1};
else
    checkneighbours=true;
end

% If periodic=true, then first call get_g_voro to evaluate g
if(periodic)
    
    % Map the seeds into the primary domain
    X=mod(X*diag(1./bx),1)*diag(bx);
    
    [g,Dg,H,actual_vols,success]=get_g_voro(w,X,target_vols,bx,periodic,checkneighbours);
    % If get_g_voro detected a problem, then it exits with success=false.
    % In this case we then call get_g_kper, as this is robust (but slower)
    if(~success)
        warning('Neighbour problem detected, switching to get_g_kper, may be slower');
        [g,Dg,H,actual_vols]=get_g_kper(w,X,target_vols,bx);
    end
else
    % If periodic=false, then call get_g_voro (which is always robust in
    % this case)
    [g,Dg,H,actual_vols,~]=get_g_voro(w,X,target_vols,bx,periodic);
end

% End of main function
end


% Function get_g_voro

function [g,Dg,H,actual_vols,success] = get_g_voro(w,X,target_vols,bx,periodic,varargin)
        
    %% WARNING! Is only accurate when the boundary between two cells is composed of a single facet
    %
    % [g,Dg,H,actual_vols,success] = get_g(w,X,target_vols,bx,periodic,OPTcheckneighbours)
    %
    % Input arguments
    %         w            - is the weights, an Nx1 array
    %         X            - is the positions, an Nx3 array
    %         target_vols  - target volumes, an Nx1 array
    %         bx           - box size, a 1x3 array
    %         periodic     - periodic flag (a boolean true/false to indicate periodic or not)
    %         OPTcheckneighbours - is an optional boolean true/false to indicate whether the function checks for problems with neighbours (multiple facets or self facets)
    
    % Return arguments
    %         g            - function g(w;x)
    %         Dg           - gradient of g wrt w
    %         H            - the Hessian d^2g, a sparse matrix
    %         actual_vols  - the actual volumes of the Laguerre diagram with seeds X and weights w
    %         success      - a flag to indicate everything has been calculated successfully
    
    %% Catch errors and process arguments
    
    % Here we check the input arguments to see if the optional 'checkneighbours' flag has been set
    if(nargin==6)
        checkneighbours=varargin{1};
    else
        checkneighbours=false;
    end
    
    [Nw,Mw]=size(w);    
    
    if(Mw~=1)
        error('w should be an N x 1 array where N is the number of cells');
    end

    [NX,MX]=size(X);

    if(MX~=3)
        error('X should be an N x 3 array where N is the number of cells');
    end

    if(NX~=Nw)
        error('The number of cells represented by w and X disagree, w: %d and X %d',Nw,NX);
    end

    [Ntv,Mtv]=size(target_vols);
    if(Mtv~=1)
        error('target_vols should be an N x 1 array where N is the number of cells');
    end

    if(Ntv~=Nw)
        error('The number of cells represented by w and target_vols disagree, w: %d and target_vols: %d',Nw,Ntv);
    end

    total_vol=sum(target_vols);
    bx_vol=bx(1)*bx(2)*bx(3);

    if(abs(total_vol-bx_vol)/bx_vol>1e-10)
        error('The sum of the target volumes is different to the volume of the box');
    end

    
    %% Computations
    
    % Use mexPDallfaces to calculate the Laguerre diagram
    [actual_vols,transport_costs,~,vfn]=mexPDallfaces(bx,X,w,periodic);
    
    % Gradient of g
    Dg=actual_vols-target_vols;

    % Definition of g, a convex function of the weights 
    g=dot(Dg,w)-sum(transport_costs); 
    
    % Preallocate memory for possible speed improvement
    % Upper bound on number of off-diagonal nonzero entries in the Hessian is the sum of the number of neighbours over all cells 
    numNZ=sum(cellfun(@length,vfn(:,3)));
    % Make a zero array of the correct size
    Z=zeros(1,numNZ);
    
    % Indices of matrix to store inter-seed distances and face areas
    AD_spvals_i=Z;
    AD_spvals_j=Z;
    
    % Values
    D_spvals_val=Z;
    A_spvals_val=Z;
    
    % Index to keep track of the number of entries in the sparse matrix
    r=1;
    
    % Loop over cells
    
    for i=1:Nw
        % Coordinates of the seed location of the ith cell
        xi=X(i,:);

        % The vertices for the ith cell
        Vertices_Cell_i=vfn{i,1};
        
        % The list of neighbour indices of the ith cell - boundaries have negative indices
        N_i=vfn{i,3};
        
        % The vertex indices for each of the faces between the cell and the neighbours in N_i
        Face_Index_i=vfn{i,2}(:,1);
        Face_Areas_i=vfn{i,2}(:,2);
        Face_Normals_i=vfn{i,2}(:,3);
        
        % The number of neighbours
        Num_N_i = size(N_i);
        
        % ERROR CHECKING, to see if a cell has a boundary with another cell composed of multiple facets, or a boundary between the cell and a periodic copy of itself
        
        if(checkneighbours)
            if(length(N_i)~=length(unique(N_i)))
                %error(sprintf('Cell with index %d has a boundary with another cell composed of multiple facets',i));
                success=false;
                H=[];
                return;
            end
            
            if(ismember(i,N_i))
                %error(sprintf('Cell with index %d has part of its boundary arising from an intersection with a periodic copy of itself',i));
                success=false;
                H=[];
                return;
            end
        end
        
        % Calculate H_ij for j in N_i 
        for j=1:Num_N_i
            
            % The cell index of neighbour j
            k = N_i(j);
            
            % We only need to calculate if the neighbour is a not a part of the boundary (non-positive k)
            if(k>0)
                
                xk=X(k,:);
                
                % The indices of the vertices for the face between cell i and cell k (neighbour j)
                Face_Vertex_Indices=Face_Index_i{j};
                
                % The face vertices for the face between cell i and cell k (neighbour j)
                Face_Vertices=Vertices_Cell_i(Face_Vertex_Indices,:);
                
                % Area of the face 
                a_ik=Face_Areas_i{j};
                
                AD_spvals_i(r)=i;
                AD_spvals_j(r)=k;
                
                A_spvals_val(r)=a_ik;
                
                % %%%%%%%%%%%%%%%%% For checking %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %                a_ik_polyarea = polygonArea3d(Face_Vertices);
                %                if(abs(a_ik-a_ik_polyarea)>1e-10)
                %                    disp(sprintf('Error in face areas at i=%d k=%d',i,k))
                %                end
                % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                % Calculate the signed distance from seed to face            
                % Find any point on face, for simplicity just choose the first vertex
                
                pt=Face_Vertices(1,:);
                
                % Get outward normal to face
                n=Face_Normals_i{j};
                
                % The signed distance to the face is
                D_spvals_val(r)=dot(pt-xi,n);
                
                % %%%%%%%%%%%%%%%%% For checking %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %                point_on_face = sum(Face_Vertices)/length(Face_Vertices);
                
                % Calculate K(x,y) and K(x,z) for x = point on the face
                %                k_xk = kper_bx(point_on_face,xk,bx);
                
                % NOTE!
                % We think that k_xi should always be zero, possible speed up
                %                k_xi = kper_bx(point_on_face,xi,bx);
                
                % del_k = K(x,y) - K(x_z)
                % del_k keeps track of which periodic copies of the seeds are used to construct the face
            
                %                del_k = k_xk - k_xi;
                %                dist_ik = norm(xi-xk+del_k*diag(bx));
                
                %                Dk_spvals_val(r)=dist_ik;
                
                % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                
                
                % Increment r to keep track of number of non-zero entries of A and D
                r=r+1;
                
            end
        end
    end
    
    % Now use AD_spvals and A_spvals and D_spvals to construct the sparse matrices containing the face areas (A)
    % and the interparticle distances (D). A is symmetric, D is not as (i,j) measures the (signed) distance from
    % particle i to the face of cell i that is formed from the cell of a periodic copy of particle j. To get the
    % interparticle distance we need to form D+D'
    
    A=sparse(AD_spvals_i(1:r-1),AD_spvals_j(1:r-1),A_spvals_val(1:r-1),Nw,Nw);
    D=sparse(AD_spvals_i(1:r-1),AD_spvals_j(1:r-1),D_spvals_val(1:r-1),Nw,Nw);

    % Construct the symmetric interparticle distance matrix (works in periodic and non-periodic case)
    D=D+D';

    % Reciprocal distance (we have to do it this way because 1./D when D is sparse makes a full matrix with lots of NaNs
    inverse_D=spfun(@(x) 1./x, D);
    
    % Construct the off-diagonal entries
    H=-0.5*A.*inverse_D;
    
    % Now having all the off-diagonal entries we can add the diagonal entries
    H=H-spdiags(sum(H)',0,Nw,Nw);
  
    % We finished!
    success=true;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Function get_g_kper
%

function [g,Dg,H,actual_vols] = get_g_kper(w,X,target_vols,bx)

% [g,Dg,H,actual_vols] = get_g(w,X,target_vols,bx)
%
% WARNING! Periodic diagrams only
%
% This function computes g, Dg, H for periodic Laguerre diagrams using the
% function kper_bx
%
% Input arguments
%         w            - is the weights, an Nx1 array
%         X            - is the positions, an Nx3 array
%         target_vols  - target volumes, an Nx1 array
%         bx           - box size, a 1x3 array
%
% Return arguments
%         g            - function g(w;x)
%         Dg           - gradient of g wrt w
%         H            - the Hessian d^2g, a sparse matrix
%         actual_vols  - the actual volumes of the Laguerre diagram with seeds X and weights w
    
    %% Catch errors
    
    [Nw,Mw]=size(w);    
    
    if(Mw~=1)
        error('w should be an N x 1 array where N is the number of cells');
    end

    [NX,MX]=size(X);

    if(MX~=3)
        error('X should be an N x 3 array where N is the number of cells');
    end

    if(NX~=Nw)
        error('The number of cells represented by w and X disagree, w: %d and X %d',Nw,NX);
    end

    [Ntv,Mtv]=size(target_vols);
    if(Mtv~=1)
        error('target_vols should be an N x 1 array where N is the number of cells');
    end

    if(Ntv~=Nw)
        error('The number of cells represented by w and target_vols disagree, w: %d and target_vols: %d',Nw,Ntv);
    end

    total_vol=sum(target_vols);
    bx_vol=bx(1)*bx(2)*bx(3);

    if(abs(total_vol-bx_vol)/bx_vol>1e-10)
        error('The sum of the target volumes is different to the volume of the box');
    end
    
    %% Computations
    
    % Use mexPDallfaces to calculate the Laguerre diagram
    % Note the diagram is assumed periodic so the last argument must be true
    [actual_vols,transport_costs,~,vfn]=mexPDallfaces(bx,X,w,true);

    % Gradient of g
    Dg=actual_vols-target_vols;

    % Definition of g, a convex function of the weights 
    g=dot(Dg,w)-sum(transport_costs); 
        
    % FUTURE DEVELOPMENT? Preallocate memory for the sparse matrix entries
    % INSERT HERE
    
    % Matrices to store the values and indices for the sparse Hessian matrix
    H_spvals_i=[];
    H_spvals_j=[];
    H_spvals_val=[];
    
    % Index to keep track of the number of entries in the sparse matrix
    r=1;
    
    % we now start computing the hessian values
    for i=1:Nw
        % Coordinates of the seed location of the ith cell
        xi=X(i,:);
        
        % The list of neighbour indices of the ith cell - boundaries have negative indices
        N_i=vfn{i,3};
        
        % The vertex indices for each of the faces between the cell and the neighbours in N_i
        Face_Index_i=vfn{i,2}(:,1);
        Face_Areas_i=vfn{i,2}(:,2);
        
        % The vertices for the ith cell
        Verticies_Cell_i=vfn{i,1};
        
        % The number of neighbours
        Num_N_i = size(N_i);
        
        % calculate H_ij for j in N_i 
        for j=1:Num_N_i
            
            % The cell index of neighbour j
            k = N_i(j);
            
            % We only need to calculate if it is a true neighbour (and we also exploit that the matrix is symmetric)
            
            if (k>i)  % Upper triangular elements only
                
                % The indices of the vertices for the face between cell i and cell k (neighbour j)
                Face_Vertex_Indices = Face_Index_i{j};
                
                % The face vertices for the face between cell i and cell k (neighbour j)
                Face_Vertices = Verticies_Cell_i(Face_Vertex_Indices,:);
                                           
                % Coordinates of the the seed for cell k
                xk = X(k,:);
                                
                % Find any point in the interior of the face
                point_on_face = sum(Face_Vertices)/length(Face_Vertices);
                
                % Calculate K(x,y) and K(x,z) for x = point on the face
                k_xk = kper_bx(point_on_face,xk,bx);
                
                % NOTE!
                % We think that k_xi should always be zero, possible speed up
                k_xi = kper_bx(point_on_face,xi,bx);
                
                % del_k = K(x,y) - K(x_z)
                % del_k keeps track of which periodic copies of the seeds are used to construct the face
            
                del_k = k_xk - k_xi;
                
                % Area of the face
                % OLD METHOD, uses MatGeom library, very slow
                % a_ik_polyarea = polygonArea3d(Face_Vertices);
              
                a_ik = Face_Areas_i{j};
                
                % The correct distance between neighbours accounts for the fact that the neighbour could
                % be a periodic copy of the original seed
                
                dist_ik = norm(xi-xk+del_k*diag(bx));
                
                % Indices and value of the Hessian
                H_spvals_i(r)=i;
                H_spvals_j(r)=k;
                H_spvals_val(r)=-0.5*a_ik/dist_ik;
                r=r+1;
            end            
        end
        
    end
    
    % Now use H_spvals to construct the sparse matrix
    H=sparse(H_spvals_i,H_spvals_j,H_spvals_val,Nw,Nw);
    
    % Having calculated the upper triangular part we can find all off-diagonal entries by adding the transpose
    H=H+H';

    % Now having all the off-diagonal entries we can add the diagonal entries
    H=H-spdiags(sum(H)',0,Nw,Nw);
    
end
