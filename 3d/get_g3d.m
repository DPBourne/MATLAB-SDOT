function [g,Dg,H,actual_vols] = get_g3d(w,X,target_vols,bx,periodic,varargin)

% [g,Dg,H,actual_vols] = get_g3d(w,X,target_vols,bx,periodic,varargin)
%
% The function evaluates the Kantorovich function g, its first derivative
% Dg, and its Hessian H, where the Kantorovich function is defined by 
%
% g(w)=\sum_i \int_{Lag_i(X,w)} (c(x,x_i)-w_i) dx + \sum_i (target_vols)_i w_i
%
% where 
%
% c(x,x_i) is either the standard quadratic cost \|x-x_i\|^2 
% (if periodic=false) or the periodic quadratic cost (if periodic=true),
%
% Lag_i(X,w) is the i-th Laguerre cell in the Laguerre tessellation of the 
% 3d box bx generated by (X,w), i.e., 
% Lag_i(X,w) = \{ x \in bx : c(x,x_i)-w_i \le c(x,x_j)-w_j for all j \}.
%
% Input arguments
%         w            - the weights of the Laguerre diagram, an Nx1 array
%         X            - the positions of the seeds, an Nx3 array
%         target_vols  - target volumes, an Nx1 array, 
%                        which must satisfy sum(target_vols)=volume(bx)
%         bx           - box size, a 1x3 array. This represents the cuboid
%                        with vertices (0,0,0), (bx(1),0,0), (0,bx(2),0), (bx(1),bx(2),0), 
%                        (0,0,bx(3)), (bx(1),0,bx(3)), (0,bx(2),bx(3)), (bx(1),bx(2),bx(3))
%         periodic     - periodic flag, a boolean true/false
%                        If periodic=false, then c is the standard quadratic cost
%                        If periodic=true, then c is the periodic quadratic cost
%         OPTcheckneighbours - optional argument, a boolean true/false
%                              Default is true. This argument is ignored if periodic=false. 
%                              Use checkneighbours=true for a robust (but slower) algorithm.
%    
% Return arguments
%         g            - the value of the Kantorovich function g(w)
%         Dg           - gradient of g with respect to w, an Nx1 array
%         H            - the Hessian D^2g, an NxN sparse matrix
%         actual_vols  - the actual volumes of the Laguerre diagram with
%         seeds X and weights w, an Nx1 array
%
% WARNING! By selecting periodic=true and checkneighbours=false there is 
% a risk that the Hessian H is incorrect. Proceed at your own risk!

%% Catch errors and process the optional argument

if(nargin==6)
    checkneighbours=varargin{1};
else
    checkneighbours=true;
end

% If periodic=true, then first call get_g_voro to evaluate g
if(periodic)
    
    % Map the seeds into the primary domain
    X=mod(X*diag(1./bx),1)*diag(bx);
    
    [g,Dg,H,actual_vols,success]=get_g_voro(w,X,target_vols,bx,periodic,checkneighbours);
    % If get_g_voro detected a problem, then it exits with success=false.
    % In this case we then call get_g_kper, as this is robust (but slower)
    if(~success)
        warning('Neighbour problem detected, switching to get_g_kper, may be slower');
        [g,Dg,H,actual_vols]=get_g_kper(w,X,target_vols,bx);
    end
else
    % If periodic=false, then call get_g_voro (which is always robust in
    % this case)
    [g,Dg,H,actual_vols,~]=get_g_voro(w,X,target_vols,bx,periodic);
end

end